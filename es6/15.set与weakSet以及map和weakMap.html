<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        /*
            set: 类似于集合的结构
            特点: 不会存在重复的值,set本身是一个构造函数,可接受一个实例或原型上有iterator的参数,set的每一项就是参数的每一项(会自动去重)
            不会发生类型转换,5 和 '5' 会被认为类型不同,不会进行转换,
            在 === 操作符中 NaN 总是与自身是不同的
            NaN在这里会被认为是相同的值(会被去重)
            
            通过size来获取集合的大小

            操作方法
                add(value)：新增，相当于 array里的push
                delete(value)：存在即删除集合中value
                has(value)：判断集合中是否存在 value
                clear()：清空集合

            可以将set转换为数组,通过Array.from实现
            由于size没有键值对(键与值是同一个),所以通过keys或values获取的是同一个数据
            set可以遍历,values方法就是它的iterator
        */
        let s = new Set([1, 3, 3, 4, 5, '5', NaN, NaN])
        // console.log(s);
        // console.log(s.size);
        // console.log(Array.from(s));
        // s.forEach(item => { console.log(item); })
        // console.log(Set.prototype[Symbol.iterator] === Set.prototype.values); // true

        /*
            weakSet与set类似,也是不重复的集合
            区别: weakSet的值只能是对象,存储的对象都是弱引用的,即垃圾回收机制不会考虑WeakSet对于存储对象的引用,一旦这个存储的对象没有其他引用,js就会回收该对象
                所以weakSet中的对象的数量取决于垃圾回收机制,因此weakSet无法被遍历
        */
        // let ws = new WeakSet([1, 2]) // 报错,虽然数组也是对象,但数组内并不是对象,
        // let ws = new WeakSet([{}, {}])
        // console.log(ws);

        /*
            map: 类对象,同样有键值对,但与传统的对象不同,map的键不局限于字符串, map的键可以任意类型
                map的键值是有序的(先进先出原则), 而传统Object不是
                Map 也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组,Map会识别数组内部的前两个元素(超过两个以上不会被Map识别到,如果传入对应元素则会用undefined代替)

                set(key,value)：新增键值对
                get(key)  获取key所对应的的value,没有就返回undefined
                delete(key)：存在即删除map的键值对,并返回true,否则返回false
                has(key)：判断集合中是否存在 key
                clear()：清空map

            map也实现了iterator遍历器,所以也可以用for..of进行遍历                
        */
        let m = new Map([[], []])
        // console.log(m);
        // let arr = ['a']
        // m.set(['a'], 5)
        // m.get(['a']) // undefined,因为不是对同一个引用对象(地址不同)

        // m.set(NaN, 1)
        // m.set(NaN, 2)
        // console.log(m.get(NaN)); // 在map中,如果NaN作为键,在多次设置NaN时,map会认为是同一个NaN


        /*
            weakMap与map的区别
                1.weakMap的键只能为对象(null除外,typeof null === 'object')
                2.weakMap的键所指向的对象,不被垃圾回收机制考虑
                3.由于垃圾回收机制,weakMap也无法进行遍历操作,并且无法清空,所以只能使用get,set,has,delete这四个方法
        */
    </script>
</body>

</html>